from sqlalchemy.orm import Session
from sqlalchemy import func, cast, Date
from sqlalchemy.sql.expression import extract
from ..models.vulnerability import VulnerabilityDefinition, VulnerabilityOccurrence
import datetime

def get_or_create_definition(db: Session, *, name: str, description: str, severity: str, signature: str) -> VulnerabilityDefinition:
    """
    Busca uma definição de vulnerabilidade pela assinatura. Se não existir, cria uma nova.
    """
    instance = db.query(VulnerabilityDefinition).filter(VulnerabilityDefinition.signature == signature).first()
    if instance:
        return instance
    else:
        new_instance = VulnerabilityDefinition(
            name=name,
            description=description,
            severity=severity,
            signature=signature
        )
        db.add(new_instance)
        db.commit()
        db.refresh(new_instance)
        return new_instance

def create_occurrence(db: Session, *, scan_id: int, asset_id: int, definition_id: int, port: str):
    """
    Cria uma nova ocorrência de vulnerabilidade.
    """
    # Antes de criar, verificar se uma ocorrência "aberta" para esta definição neste ativo já existe.
    existing_open = db.query(VulnerabilityOccurrence).filter(
        VulnerabilityOccurrence.definition_id == definition_id,
        VulnerabilityOccurrence.asset_id == asset_id,
        VulnerabilityOccurrence.status == 'open'
    ).first()

    if existing_open:
        print(f"Ocorrência aberta já existe para a definição {definition_id} no ativo {asset_id}. Pulando.")
        return None # Ou podemos atualizar um timestamp de "last_seen"

    new_occurrence = VulnerabilityOccurrence(
        scan_id=scan_id,
        asset_id=asset_id,
        definition_id=definition_id,
        port=port
    )
    db.add(new_occurrence)
    db.commit()
    db.refresh(new_occurrence)
    return new_occurrence

def process_vulnerabilities_from_scan(db: Session, *, scan: "Scan", vulnerabilities_data: list):
    """
    Processa uma lista de dados de vulnerabilidades de um scan, correlacionando e criando ocorrências.
    """
    asset_id = scan.asset_id
    for vuln_data in vulnerabilities_data:
        # Criar uma assinatura única para a correlação
        # Para SAST (semgrep, sonar), a assinatura pode ser "rule_id:file_path"
        # Para DAST/Infra (zap, openvas), pode ser "plugin_id:host"
        # Simplificando por enquanto:
        signature = f"{vuln_data.get('name')}:{vuln_data.get('host')}"

        definition = get_or_create_definition(
            db,
            name=vuln_data.get('name'),
            description=vuln_data.get('description'),
            severity=vuln_data.get('severity'),
            signature=signature
        )

        create_occurrence(
            db,
            scan_id=scan.id,
            asset_id=asset_id,
            definition_id=definition.id,
            port=vuln_data.get('port')
        )

# Funções de métricas precisarão ser atualizadas para usar VulnerabilityOccurrence
def get_vulnerability_counts_by_severity(db: Session):
    return db.query(VulnerabilityDefinition.severity, func.count(VulnerabilityOccurrence.id)).\
        join(VulnerabilityDefinition).\
        group_by(VulnerabilityDefinition.severity).all()

# ... (outras funções de métricas seriam refatoradas de forma semelhante) ...
